"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8551],{78306:function(e,r,t){t.d(r,{G:function(){return BaseError}});var n,o,a=t(81784);let getVersion=()=>`@wagmi/core@${a.i}`;var __classPrivateFieldGet=function(e,r,t,n){if("a"===t&&!n)throw TypeError("Private accessor was defined without a getter");if("function"==typeof r?e!==r||!n:!r.has(e))throw TypeError("Cannot read private member from an object whose class did not declare it");return"m"===t?n:"a"===t?n.call(e):n?n.value:r.get(e)};let BaseError=class BaseError extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return getVersion()}constructor(e,r={}){super(),n.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});let t=r.cause instanceof BaseError?r.cause.details:r.cause?.message?r.cause.message:r.details,o=r.cause instanceof BaseError&&r.cause.docsPath||r.docsPath;this.message=[e||"An error occurred.","",...r.metaMessages?[...r.metaMessages,""]:[],...o?[`Docs: ${this.docsBaseUrl}${o}.html${r.docsSlug?`#${r.docsSlug}`:""}`]:[],...t?[`Details: ${t}`]:[],`Version: ${this.version}`].join("\n"),r.cause&&(this.cause=r.cause),this.details=t,this.docsPath=o,this.metaMessages=r.metaMessages,this.shortMessage=e}walk(e){return __classPrivateFieldGet(this,n,"m",o).call(this,this,e)}};n=new WeakSet,o=function _BaseError_walk(e,r){return r?.(e)?e:e.cause?__classPrivateFieldGet(this,n,"m",_BaseError_walk).call(this,e.cause,r):e}},76026:function(e,r,t){t.d(r,{$S:function(){return ConnectorUnavailableReconnectingError},JK:function(){return ConnectorAccountNotFoundError},X4:function(){return ChainNotConfiguredError},XZ:function(){return ConnectorChainMismatchError},aH:function(){return ConnectorNotConnectedError},wi:function(){return ConnectorAlreadyConnectedError}});var n=t(78306);let ChainNotConfiguredError=class ChainNotConfiguredError extends n.G{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}};let ConnectorAlreadyConnectedError=class ConnectorAlreadyConnectedError extends n.G{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}};let ConnectorNotConnectedError=class ConnectorNotConnectedError extends n.G{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}};let ConnectorAccountNotFoundError=class ConnectorAccountNotFoundError extends n.G{constructor({address:e,connector:r}){super(`Account "${e}" not found for connector "${r.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}};let ConnectorChainMismatchError=class ConnectorChainMismatchError extends n.G{constructor({connectionChainId:e,connectorChainId:r}){super(`The current chain of the connector (id: ${r}) does not match the connection's chain (id: ${e}).`,{metaMessages:[`Current Chain ID:  ${r}`,`Expected Chain ID: ${e}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}};let ConnectorUnavailableReconnectingError=class ConnectorUnavailableReconnectingError extends n.G{constructor({connector:e}){super(`Connector "${e.name}" unavailable while reconnecting.`,{details:"During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started."}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorUnavailableReconnectingError"})}}},29358:function(e,r,t){t.d(r,{M:function(){return ProviderNotFoundError},O:function(){return SwitchChainNotSupportedError}});var n=t(78306);let ProviderNotFoundError=class ProviderNotFoundError extends n.G{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}};let SwitchChainNotSupportedError=class SwitchChainNotSupportedError extends n.G{constructor({connector:e}){super(`"${e.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}}},81784:function(e,r,t){t.d(r,{i:function(){return n}});let n="2.16.7"},58551:function(e,r,t){t.d(r,{switchChain:function(){return switchChain}});var n=t(76026),o=t(29358);async function switchChain(e,r){let{addEthereumChainParameter:t,chainId:a}=r,c=e.state.connections.get(r.connector?.uid??e.state.current);if(c){let e=c.connector;if(!e.switchChain)throw new o.O({connector:e});let r=await e.switchChain({addEthereumChainParameter:t,chainId:a});return r}let i=e.chains.find(e=>e.id===a);if(!i)throw new n.X4;return e.setState(e=>({...e,chainId:a})),i}}}]);