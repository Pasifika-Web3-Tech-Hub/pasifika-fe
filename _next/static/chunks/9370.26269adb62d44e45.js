"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9370],{98598:function(t,e,n){function toBase64(t,e){let n=btoa(function(t){let e="";for(let n=0;n<t.length;n+=1)e+=String.fromCharCode(t[n]);return e}(t)).replace(/=/g,"");return n.replace(/\+/g,"-").replace(/\//g,"_")}/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts
 * - The implementation of integerToByteArray has been modified to augment the resulting byte array to a certain length.
 * - The implementation of PointDecode has been modified to decode both compressed and uncompressed points by checking for correct format
 * - Method isP256CurvePoint added to check whether an uncompressed point is valid
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function getModulus(){return BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951")}function getB(){return BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b")}function byteArrayToInteger(t){return BigInt("0x"+function(t){let e="";for(let n=0;n<t.length;n++){let r=t[n].toString(16);e+=r.length>1?r:"0"+r}return e}(t))}function integerToByteArray(t,e){let n=t.toString(16),r=2*e,i="";if(r<n.length)throw Error(`cannot pack integer with ${n.length} hex chars into ${e} bytes`);return(/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function(t){if(t.length%2!=0)throw Error("Hex string length must be multiple of 2");let e=new Uint8Array(t.length/2);for(let n=0;n<t.length;n+=2)e[n/2]=parseInt(t.substring(n,n+2),16);return e}("0".repeat(r-n.length)+n))}function testBit(t,e){let n=BigInt(1)<<BigInt(e);return(t&n)!==BigInt(0)}n.d(e,{Y:function(){return convertTurnkeyApiKeyToJwk}});var r=n(74495);function convertTurnkeyApiKeyToJwk(t){let{uncompressedPrivateKeyHex:e,compressedPublicKeyHex:n}=t,i=function(t){if(33!==t.length&&65!==t.length)throw Error("Invalid length: point is not in compressed or uncompressed format");if((2===t[0]||3===t[0])&&33==t.length){let e=3===t[0],n=byteArrayToInteger(t.subarray(1,t.length)),r=getModulus();if(n<BigInt(0)||n>=r)throw Error("x is out of range");let i=function(t,e){let n=getModulus(),r=n-BigInt(3),i=getB(),o=((t*t+r)*t+i)%n,g=function(t,e){if(e<=BigInt(0))throw Error("p must be positive");let n=t%e;if(testBit(e,0)&&testBit(e,1)){let t=e+BigInt(1)>>BigInt(2),r=function(t,e,n){if(e===BigInt(0))return BigInt(1);let r=t,i=e.toString(2);for(let e=1;e<i.length;++e)r=r*r%n,"1"===i[e]&&(r=r*t%n);return r}(n,t,e);if(r*r%e!==n)throw Error("could not find a modular square root");return r}throw Error("unsupported modulus value")}(o,n);return e!==testBit(g,0)&&(g=(n-g)%n),g}(n,e),o={kty:"EC",crv:"P-256",x:toBase64(integerToByteArray(n,32)),y:toBase64(integerToByteArray(i,32)),ext:!0};return o}if(4===t[0]&&65==t.length){let e=byteArrayToInteger(t.subarray(1,33)),n=byteArrayToInteger(t.subarray(33,65)),r=getModulus();if(e<BigInt(0)||e>=r||n<BigInt(0)||n>=r||!function(t,e){let n=getModulus(),r=n-BigInt(3),i=getB(),o=e**BigInt(2)%n;return o===((t*t+r)*t+i)%n}(e,n))throw Error("invalid uncompressed x and y coordinates");let i={kty:"EC",crv:"P-256",x:toBase64(integerToByteArray(e,32)),y:toBase64(integerToByteArray(n,32)),ext:!0};return i}throw Error("invalid format")}((0,r.q8)(n));return i.d=(0,r.bN)(e,r.HS),i}},99370:function(t,e,n){n.r(e),n.d(e,{signWithApiKey:function(){return signWithApiKey}});var r=n(98598),i=n(74495);let signWithApiKey=async t=>{let{content:e,publicKey:n,privateKey:r}=t,i=await importTurnkeyApiKey({uncompressedPrivateKeyHex:r,compressedPublicKeyHex:n});return await signMessage({key:i,content:e})};async function importTurnkeyApiKey(t){let{uncompressedPrivateKeyHex:e,compressedPublicKeyHex:n}=t,i=(0,r.Y)({uncompressedPrivateKeyHex:e,compressedPublicKeyHex:n});return await crypto.subtle.importKey("jwk",i,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}async function signMessage(t){let{key:e,content:n}=t,r=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},e,new TextEncoder().encode(n)),o=function(t){let e;if(t.length%2!=0||0==t.length||t.length>132)throw Error("Invalid IEEE P1363 signature encoding. Length: "+t.length);let n=toUnsignedBigNum(t.subarray(0,t.length/2)),r=toUnsignedBigNum(t.subarray(t.length/2,t.length)),i=0,o=2+n.length+1+1+r.length;return o>=128?((e=new Uint8Array(o+3))[i++]=48,e[i++]=129):(e=new Uint8Array(o+2))[i++]=48,e[i++]=o,e[i++]=2,e[i++]=n.length,e.set(n,i),i+=n.length,e[i++]=2,e[i++]=r.length,e.set(r,i),e}(new Uint8Array(r));return(0,i.fv)(o)}function toUnsignedBigNum(t){let e=0;for(;e<t.length&&0==t[e];)e++;e==t.length&&(e=t.length-1);let n=0;(128&t[e])==128&&(n=1);let r=new Uint8Array(t.length-e+n);return r.set(t.subarray(e),n),r}}}]);