(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8952],{89996:function(){},68952:function(t,e,r){"use strict";r.r(e),r.d(e,{signWithApiKey:function(){return signWithApiKey}});var n=r(89996),i=r(98598),o=r(67133).Buffer;let signWithApiKey=async t=>{let{content:e,publicKey:r,privateKey:u}=t,g=n.createPrivateKey({key:(0,i.Y)({uncompressedPrivateKeyHex:u,compressedPublicKeyHex:r}),format:"jwk"}),l=n.createSign("SHA256");return l.write(o.from(e)),l.end(),l.sign(g,"hex")}},98598:function(t,e,r){"use strict";function toBase64(t,e){let r=btoa(function(t){let e="";for(let r=0;r<t.length;r+=1)e+=String.fromCharCode(t[r]);return e}(t)).replace(/=/g,"");return r.replace(/\+/g,"-").replace(/\//g,"_")}/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts
 * - The implementation of integerToByteArray has been modified to augment the resulting byte array to a certain length.
 * - The implementation of PointDecode has been modified to decode both compressed and uncompressed points by checking for correct format
 * - Method isP256CurvePoint added to check whether an uncompressed point is valid
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function getModulus(){return BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951")}function getB(){return BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b")}function byteArrayToInteger(t){return BigInt("0x"+function(t){let e="";for(let r=0;r<t.length;r++){let n=t[r].toString(16);e+=n.length>1?n:"0"+n}return e}(t))}function integerToByteArray(t,e){let r=t.toString(16),n=2*e,i="";if(n<r.length)throw Error(`cannot pack integer with ${r.length} hex chars into ${e} bytes`);return(/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function(t){if(t.length%2!=0)throw Error("Hex string length must be multiple of 2");let e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substring(r,r+2),16);return e}("0".repeat(n-r.length)+r))}function testBit(t,e){let r=BigInt(1)<<BigInt(e);return(t&r)!==BigInt(0)}r.d(e,{Y:function(){return convertTurnkeyApiKeyToJwk}});var n=r(74495);function convertTurnkeyApiKeyToJwk(t){let{uncompressedPrivateKeyHex:e,compressedPublicKeyHex:r}=t,i=function(t){if(33!==t.length&&65!==t.length)throw Error("Invalid length: point is not in compressed or uncompressed format");if((2===t[0]||3===t[0])&&33==t.length){let e=3===t[0],r=byteArrayToInteger(t.subarray(1,t.length)),n=getModulus();if(r<BigInt(0)||r>=n)throw Error("x is out of range");let i=function(t,e){let r=getModulus(),n=r-BigInt(3),i=getB(),o=((t*t+n)*t+i)%r,u=function(t,e){if(e<=BigInt(0))throw Error("p must be positive");let r=t%e;if(testBit(e,0)&&testBit(e,1)){let t=e+BigInt(1)>>BigInt(2),n=function(t,e,r){if(e===BigInt(0))return BigInt(1);let n=t,i=e.toString(2);for(let e=1;e<i.length;++e)n=n*n%r,"1"===i[e]&&(n=n*t%r);return n}(r,t,e);if(n*n%e!==r)throw Error("could not find a modular square root");return n}throw Error("unsupported modulus value")}(o,r);return e!==testBit(u,0)&&(u=(r-u)%r),u}(r,e),o={kty:"EC",crv:"P-256",x:toBase64(integerToByteArray(r,32)),y:toBase64(integerToByteArray(i,32)),ext:!0};return o}if(4===t[0]&&65==t.length){let e=byteArrayToInteger(t.subarray(1,33)),r=byteArrayToInteger(t.subarray(33,65)),n=getModulus();if(e<BigInt(0)||e>=n||r<BigInt(0)||r>=n||!function(t,e){let r=getModulus(),n=r-BigInt(3),i=getB(),o=e**BigInt(2)%r;return o===((t*t+n)*t+i)%r}(e,r))throw Error("invalid uncompressed x and y coordinates");let i={kty:"EC",crv:"P-256",x:toBase64(integerToByteArray(e,32)),y:toBase64(integerToByteArray(r,32)),ext:!0};return i}throw Error("invalid format")}((0,n.q8)(r));return i.d=(0,n.bN)(e,n.HS),i}}}]);